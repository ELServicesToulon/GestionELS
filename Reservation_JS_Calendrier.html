<script>
/**
 * =================================================================
 * MODULE JAVASCRIPT - CALENDRIER
 * =================================================================
 * Affiche le calendrier mensuel et gère l'état de disponibilité.
 */

const SVG_NS = 'http://www.w3.org/2000/svg';
const CAPSULE_PROGRESS_VIEWBOX = '0 0 100 100';
const CAPSULE_PROGRESS_PATH_LENGTH = 100;
const CAPSULE_PROGRESS_RECT = {
  x: '3',
  y: '3',
  width: '94',
  height: '94',
  rx: '47',
  ry: '47'
};
const CAPSULE_PROGRESS_GRADIENT_COLORS = ['#8e44ad', '#3498db', '#5dade2'];
const CAPSULE_PROGRESS_EASING_EXPONENT = 1.6;
let capsuleProgressSequence = 0;

/**
 * Crée au besoin l'overlay SVG qui dessine la progression autour de la gélule.
 * @param {HTMLElement} cellule
 * @returns {{svg: SVGElement, fill: SVGElement}|null}
 */
function assurerProgressionCapsule(cellule) {
  if (!cellule) return null;

  let svg = cellule.querySelector('.capsule-progress');
  if (svg) {
    return {
      svg,
      fill: svg.querySelector('.capsule-progress-fill')
    };
  }

  svg = document.createElementNS(SVG_NS, 'svg');
  svg.classList.add('capsule-progress');
  svg.setAttribute('viewBox', CAPSULE_PROGRESS_VIEWBOX);
  svg.setAttribute('preserveAspectRatio', 'none');
  svg.setAttribute('aria-hidden', 'true');

  const defs = document.createElementNS(SVG_NS, 'defs');
  const gradient = document.createElementNS(SVG_NS, 'linearGradient');
  const gradientId = `capsule-progress-gradient-${++capsuleProgressSequence}`;
  gradient.setAttribute('id', gradientId);
  gradient.setAttribute('gradientUnits', 'objectBoundingBox');
  gradient.setAttribute('x1', '0%');
  gradient.setAttribute('y1', '0%');
  gradient.setAttribute('x2', '100%');
  gradient.setAttribute('y2', '100%');

  const steps = Math.max(1, CAPSULE_PROGRESS_GRADIENT_COLORS.length - 1);
  CAPSULE_PROGRESS_GRADIENT_COLORS.forEach((color, index) => {
    const stop = document.createElementNS(SVG_NS, 'stop');
    const offset = steps === 0 ? 0 : (index / steps) * 100;
    stop.setAttribute('offset', `${offset}%`);
    stop.setAttribute('stop-color', color);
    gradient.appendChild(stop);
  });

  defs.appendChild(gradient);
  svg.appendChild(defs);

  const track = document.createElementNS(SVG_NS, 'rect');
  track.classList.add('capsule-progress-track');
  track.setAttribute('pathLength', CAPSULE_PROGRESS_PATH_LENGTH);
  track.setAttribute('vector-effect', 'non-scaling-stroke');
  track.setAttribute('stroke-linecap', 'round');
  track.setAttribute('stroke-width', '4');
  track.setAttribute('stroke', 'rgba(255, 255, 255, 0.4)');

  const fill = document.createElementNS(SVG_NS, 'rect');
  fill.classList.add('capsule-progress-fill');
  fill.setAttribute('pathLength', CAPSULE_PROGRESS_PATH_LENGTH);
  fill.setAttribute('vector-effect', 'non-scaling-stroke');
  fill.setAttribute('stroke-linecap', 'round');
  fill.setAttribute('stroke-width', '4');
  fill.setAttribute('stroke-dasharray', CAPSULE_PROGRESS_PATH_LENGTH);
  fill.setAttribute('stroke-dashoffset', CAPSULE_PROGRESS_PATH_LENGTH);
  fill.setAttribute('stroke', `url(#${gradientId})`);

  Object.keys(CAPSULE_PROGRESS_RECT).forEach(attr => {
    const value = CAPSULE_PROGRESS_RECT[attr];
    track.setAttribute(attr, value);
    fill.setAttribute(attr, value);
  });

  svg.appendChild(track);
  svg.appendChild(fill);
  cellule.appendChild(svg);

  return { svg, fill };
}

/**
 * Met à jour le tracé de progression autour de la gélule en fonction du taux de disponibilité.
 * @param {HTMLElement} cellule
 * @param {number} disponibilite Valeur entre 0 (complet) et 1 (tout libre)
 */
function mettreAJourProgressionCapsule(cellule, disponibilite) {
  if (!cellule || !Number.isFinite(disponibilite)) return;

  const clamped = Math.max(0, Math.min(1, disponibilite));
  const eased = Math.pow(clamped, CAPSULE_PROGRESS_EASING_EXPONENT);
  cellule.dataset.progress = eased.toFixed(3);
  cellule.dataset.progressLinear = clamped.toFixed(3);

  const result = assurerProgressionCapsule(cellule);
  if (!result || !result.fill) return;

  const offset = (CAPSULE_PROGRESS_PATH_LENGTH * (1 - eased)).toFixed(2);
  result.fill.setAttribute('stroke-dashoffset', offset);
}

/**
 * Affiche le calendrier pour un mois et une année donnés.
 * @param {number} mois 1=Janvier ... 12=Décembre
 * @param {number} annee Année (ex: 2025)
 */
function afficherCalendrier(mois, annee) {
  basculerIndicateurChargement(true);

  google.script.run
    .withSuccessHandler(donnees => {
      const { grilleCalendrier, titreCalendrier } = window.ui || {};
      if (!grilleCalendrier || !titreCalendrier) {
        basculerIndicateurChargement(false);
        return;
      }

      if (donnees && donnees.disponibilite) {
        window.etat.donneesCalendrier = donnees.disponibilite;
        grilleCalendrier.textContent = '';

        titreCalendrier.textContent = new Date(annee, mois - 1)
          .toLocaleString('fr-FR', { month: 'long', year: 'numeric' });

        const premierJour = new Date(annee, mois - 1, 1).getDay();
        const joursDansLeMois = new Date(annee, mois, 0).getDate();
        const aujourdhui = new Date();
        aujourdhui.setHours(0, 0, 0, 0);
        const todayISO = `${aujourdhui.getFullYear()}-${String(aujourdhui.getMonth() + 1).padStart(2, '0')}-${String(aujourdhui.getDate()).padStart(2, '0')}`;

        // Cases vides d'offset (lundi=1 -> 0 offset, dimanche=0 -> 6)
        for (let i = 0; i < (premierJour === 0 ? 6 : premierJour - 1); i++) {
          const celluleVide = document.createElement('div');
          celluleVide.setAttribute('role', 'gridcell');
          grilleCalendrier.appendChild(celluleVide);
        }

        for (let jour = 1; jour <= joursDansLeMois; jour++) {
          const cellule = document.createElement('div');
          cellule.setAttribute('role', 'gridcell');
          const date = new Date(annee, mois - 1, jour);
          const y = annee;
          const m = String(mois).padStart(2, '0');
          const d = String(jour).padStart(2, '0');
          const dateISO = `${y}-${m}-${d}`;
          const dispo = window.etat.donneesCalendrier[dateISO] || { disponibles: 0, total: 0 };

          cellule.className = 'jour-calendrier';
          const spanJour = document.createElement('span');
          spanJour.textContent = jour;
          cellule.appendChild(spanJour);

          const estDimanche = date.getDay() === 0;
          const estComplet = dispo.disponibles === 0;
          const estPasse = dateISO < todayISO; // compare AAAA-MM-JJ
          const estReservable = !estPasse && !estDimanche && !estComplet;
          const ratio = (dispo.total > 0) ? (dispo.disponibles / dispo.total) : 0;

          cellule.classList.toggle('desactive', !estReservable);
          cellule.tabIndex = estReservable ? 0 : -1;
          cellule.setAttribute('aria-disabled', (!estReservable).toString());

          if (estReservable) {
            cellule.dataset.date = dateISO;
            cellule.setAttribute('aria-label', `${dispo.disponibles} créneaux disponibles`);
            const barre = document.createElement('div');
            barre.className = 'barre-disponibilite';
            const rempl = document.createElement('div');
            rempl.style.width = `${Math.min(100, Math.max(0, ratio * 100))}%`;
            if (window.etat?.flags?.calendarBarOpacityEnabled) {
              const charge = 1 - ratio;
              rempl.style.opacity = Math.min(1, Math.max(0, charge));
            }
            barre.appendChild(rempl);
            cellule.appendChild(barre);
          }

          if (dispo.total > 0) {
            mettreAJourProgressionCapsule(cellule, ratio);
          } else {
            delete cellule.dataset.progress;
            delete cellule.dataset.progressLinear;
            const overlay = cellule.querySelector('.capsule-progress');
            if (overlay) overlay.remove();
          }

          grilleCalendrier.appendChild(cellule);
        }
      } else {
        afficherErreur("Les données du calendrier n'ont pas pu être chargées.");
      }
      basculerIndicateurChargement(false);
    })
    .withFailureHandler(afficherErreur)
    .obtenirDonneesCalendrierPublic(mois, annee);
}

/**
 * Ajuste dynamiquement l'affichage de disponibilité pour un jour donné.
 * Utilisé lors de l'ajout/suppression d'éléments du panier afin de
 * mettre à jour la "barre" sans recharger tout le mois.
 * @param {string} dateISO Format YYYY-MM-DD
 * @param {number} delta Variation du nombre de créneaux disponibles (ex: -1, +1)
 */
function ajusterDisponibiliteJour(dateISO, delta) {
  try {
    if (!window.etat || !window.etat.donneesCalendrier) return;
    const record = window.etat.donneesCalendrier[dateISO];
    if (!record || typeof record.disponibles !== 'number' || typeof record.total !== 'number') return;

    // Mettre à jour le modèle
    record.disponibles = Math.max(0, Math.min(record.total, record.disponibles + delta));

    // Mettre à jour le DOM
    const cellule = document.querySelector(`.jour-calendrier[data-date="${dateISO}"]`);
    if (!cellule) return;

    const barre = cellule.querySelector('.barre-disponibilite');
    let rempl = barre ? barre.firstElementChild : null;
    if (!barre) {
      // Si la barre n’existe pas encore (rare), la créer
      const nouvelleBarre = document.createElement('div');
      nouvelleBarre.className = 'barre-disponibilite';
      const nouveauRempl = document.createElement('div');
      nouvelleBarre.appendChild(nouveauRempl);
      cellule.appendChild(nouvelleBarre);
      rempl = nouveauRempl;
    }

    const ratio = record.total > 0 ? (record.disponibles / record.total) : 0;
    if (rempl) rempl.style.width = `${Math.min(100, Math.max(0, ratio * 100))}%`;
    if (record.total > 0) {
      mettreAJourProgressionCapsule(cellule, ratio);
    } else {
      delete cellule.dataset.progress;
      delete cellule.dataset.progressLinear;
      const overlay = cellule.querySelector('.capsule-progress');
      if (overlay) overlay.remove();
    }

    // Désactiver si complet
    if (record.disponibles === 0) {
      cellule.classList.add('desactive');
      cellule.removeAttribute('data-date');
      cellule.setAttribute('aria-label', 'Aucun créneau disponible');
    } else {
      cellule.classList.remove('desactive');
      cellule.dataset.date = dateISO;
      cellule.setAttribute('aria-label', `${record.disponibles} créneaux disponibles`);
    }
  } catch (e) {
    // Pas de bruit en UI si échec mineur
    console && console.warn && console.warn('ajusterDisponibiliteJour error', e);
  }
}
</script>
