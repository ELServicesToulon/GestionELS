<script>
/**
 * Fonctions utilitaires de tarification pour le client.
 * S'appuie sur la matrice pré-calculée fournie par le serveur.
 */
function shouldApplyPricingRulesV2(forcedVersion) {
  if (forcedVersion === 'v1') return false;
  if (forcedVersion === 'v2') return true;
  return !!(typeof configServeur !== 'undefined' && configServeur.PRICING_RULES_V2_ENABLED);
}

function getPricingMatrix() {
  return (typeof configServeur !== 'undefined' && configServeur.PRICING_MATRIX) ? configServeur.PRICING_MATRIX : {};
}

function buildPricingKey(opts = {}) {
  const stops = Math.max(1, Number(opts.totalStops) || 1);
  const retour = opts.retour === true;
  const samedi = opts.samedi === true;
  const urgent = opts.urgent === true && !samedi;
  return [stops, retour ? 1 : 0, samedi ? 1 : 0, urgent ? 1 : 0].join('|');
}

function computeCoursePrice(opts = {}) {
  const matrix = getPricingMatrix();
  const key = buildPricingKey(opts);
  const hit = matrix[key];
  if (hit) {
    return hit;
  }
  console.warn('[Pricing] Aucune entrée pré-calculée pour la clé', key);
  const stops = Math.max(1, Number(opts.totalStops) || 1);
  return {
    total: 0,
    formattedTotal: '0,00 €',
    nbSupp: Math.max(0, stops - 1),
    breakdown: {
      base: 0,
      supplements: 0,
      retour: 0,
      samedi: 0,
      urgent: 0,
      remise: 0
    },
    missing: true
  };
}

function formatCourseLabel(dureeMin, totalStops, isReturn) {
  const extra = Math.max((Number(totalStops) || 0) - 1, 0);
  let detail = `${extra} supp.`;
  if (isReturn && shouldApplyPricingRulesV2()) {
    detail += ' + retour';
  }
  return `Tournée de ${dureeMin}min (${totalStops} arrêt(s) total(s) (dont ${detail}), retour: ${isReturn ? 'oui' : 'non'})`;
}
</script>
